{"mult_theorem0": "Theorem theorem0 : forall (n : INT) (m : INT), eq (mult n m) (mult m n).", "queue_popback_len_butlast": "Lemma len_butlast : forall (l : lst) (n : nat), S (len (butlast (Cons n l))) = len (Cons n l).", "queue_popback_theorem0": "Theorem theorem0 : forall (q : queue) (n : nat), isAmortized q && negb (isEmpty q) = true -> eq (plus 1 (qlen (qpopback q))) (qlen q).", "list_rev_append_app_nil": "Lemma app_nil : forall x : lst, app x Nil = x.", "list_rev_append_app_assoc": "Lemma app_assoc : forall x y z : lst, app x (app y z) = app (app x y) z.", "list_rev_append_rev_append": "Theorem rev_append: forall x y : lst,  (eq (rev (app x y)) (app (rev y) (rev x))).", "heap_insert_multi_rank_right_height": "Lemma rank_right_height : forall h : heap,  has_leftist_property h = true -> rank h = right_height h.", "heap_insert_multi_leftist_mergea": "Lemma leftist_mergea : forall (v : nat) (l r : heap),  has_leftist_property l && has_leftist_property r = true    -> has_leftist_property (mergea v l r) = true.", "heap_insert_multi_leftist_merge": "Lemma leftist_merge : forall h1 h2 : heap,  has_leftist_property h1 && has_leftist_property h2 = true    -> has_leftist_property (merge h1 h2) = true.", "heap_insert_multi_leftist_hinsert": "Theorem leftist_hinsert : forall (x : heap) (n : nat),  has_leftist_property x = true -> has_leftist_property (hinsert x n) = true.", "heap_insert_multi_theorem1": "Theorem theorem1 : forall (l : lst) (h : heap), eq (has_leftist_property h) true -> eq (has_leftist_property (hinsert_all l h)) true.", "queue_push_to_list_append_nil": "Lemma append_nil : forall (l : lst), append l Nil = l.", "queue_push_to_list_theorem0": "Theorem theorem0 : forall (q : queue) (n : nat), eq (append (queue_to_lst q) (Cons n Nil)) (queue_to_lst (qpush q n)).", "heap_insert_hsize_nonneg": "Lemma hsize_nonneg : forall h : heap, hsize h >= 0.", "heap_insert_rank_right_height": "Lemma rank_right_height : forall h : heap,  has_leftist_property h = true -> rank h = right_height h.", "heap_insert_leftist_mergea": "Lemma leftist_mergea : forall (v : nat) (l r : heap),  has_leftist_property l && has_leftist_property r = true    -> has_leftist_property (mergea v l r) = true.", "heap_insert_leftist_merge": "Lemma leftist_merge : forall h1 h2 : heap,  has_leftist_property h1 && has_leftist_property h2 = true    -> has_leftist_property (merge h1 h2) = true.", "heap_insert_leftist_hinsert": "Theorem leftist_hinsert : forall (x : heap) (n : nat),  has_leftist_property x = true -> has_leftist_property (hinsert x n) = true.", "list_rev_append_nil": "Lemma append_nil : forall x : lst, append x Nil = x.", "list_rev_append_assoc": "Lemma append_assoc : forall x y z : lst,  append x (append y z) = append (append x y) z.", "list_rev_rev_append": "Lemma rev_append: forall x y : lst, rev (append x y) = append (rev y) (rev x).", "list_rev_double_rev": "Theorem double_rev : forall x : lst, rev (rev x) = x.", "list_rev_len_len_append": "Lemma len_append : forall x y : lst, len (append x y) = len x + len y.", "list_rev_len_len_rev": "Theorem len_rev : forall x : lst, len (rev x) = len x.", "queue_push_len_app": "Lemma len_app : forall l1 l2, len (app l1 l2) = (len l1) + (len l2).", "queue_push_plus_comm": "Lemma plus_comm: forall m n, m + n = n + m.", "queue_push_len_rev": "Lemma len_rev : forall l, len (rev l) = len l.", "queue_push_queue_push": "Theorem queue_push : forall q n, qlen (qpush q n) = 1 + (qlen q).", "list_rev2_append_rev2_append_aux": "Lemma rev2_append_aux : forall x a b : lst,  append (rev2 x Nil) (append a b) = append (rev2 x a) b.", "list_rev2_append_append_single": "Lemma append_single : forall (n : nat) (a : lst),  append (Cons n Nil) a = Cons n a.", "list_rev2_append_rev2_append": "Theorem rev2_append : forall x a : lst, rev2 x a = append (rev2 x Nil) a.", "list_rev2_len_list_rev2_len_lem": "Lemma list_rev2_len_lem: forall l1 l2, len (rev l1 l2) = (len l1) + (len l2).", "list_rev2_len_list_rev2_len": "Theorem list_rev2_len: forall l: lst, len (rev l Nil) = len l.", "list_append_len_theorem0": "Theorem theorem0 : forall (x : Lst) (y : Lst), eq (len (append x y)) (plus (len x) (len y)).", "list_len_theorem0": "Theorem theorem0 : forall (x : Lst), ge (len x) 0.", "heap_size_theorem0": "Theorem theorem0 : forall (x : Heap), ge (hsize x) 0.", "list_append_nil_theorem0": "Theorem theorem0 : forall (x : Lst), eq x (append x nil).", "list_rev2_rev2_append_aux": "Lemma rev2_append_aux : forall x a b : lst,  append (rev2 x Nil) (append a b) = append (rev2 x a) b.", "list_rev2_append_single": "Lemma append_single : forall (n : nat) (a : lst),  append (Cons n Nil) a = Cons n a.", "list_rev2_rev2_append": "Lemma rev2_append : forall x a : lst, rev2 x a = append (rev2 x Nil) a.", "list_rev2_rev_eq_rev2": "Theorem rev_eq_rev2 : forall x : lst, rev2 x Nil = rev x.", "queue_amort_theorem0": "Theorem theorem0 : forall (x : Lst) (y : Lst), eq (isAmortized (amortizeQueue x y)) true.", "tree_insert_all_leb_refl": "Lemma leb_refl : forall n, leb n n = true.", "tree_insert_all_leb_m_Sn": "Lemma leb_m_Sn : forall m n, leb m n = true -> leb m (S n) = true.", "tree_insert_all_helper": "Lemma helper : forall t n, (tsize (tinsert t n)) = S (tsize t).", "tree_insert_all_tree_insert_all": "Theorem tree_insert_all : forall l t,  (tsize t)  <= (tsize (tinsert_all t l)).", "list_rev_no_lemma_append_assoc": "Theorem append_assoc : forall x y z : lst, append (append x y) z = append x (append y z).", "list_rev_no_lemma_rev_append_cons_aux": "Theorem rev_append_cons_aux : forall (l1 l2 : lst) (x : nat), rev (append (rev l1) (Cons x l2)) = append (rev l2) (Cons x l1).", "list_rev_no_lemma_rev_append_cons": "Theorem rev_append_cons : forall (l : lst) (x : nat), rev (append (rev l) (Cons x Nil)) = Cons x l.", "queue_len_len_pos": "Lemma len_pos: forall l, (len l) >= 0.", "queue_len_len_app": "Lemma len_app : forall l1 l2, len (app l1 l2) = (len l1) + (len l2).", "queue_len_plus_comm": "Lemma plus_comm: forall m n, m + n = n + m.", "queue_len_len_rev": "Lemma len_rev : forall l, len (rev l) = len l.", "queue_len_queue_len": "Theorem queue_len : forall l1 l2, qlen (amortizeQueue l1 l2) = (len l1) + (len l2).", "list_len_butlast_theorem0": "Theorem theorem0 : forall (x : Lst) (n : nat), eq (Lst_beq (cons n x) nil) false.", "list_len_butlast_theorem1": "Theorem theorem1 : forall (x : Lst) (n : nat), eq (plus 1 (len (butlast (cons n x)))) (len (cons n x)).", "tree_insert_size_theorem0": "Theorem theorem0 : forall (t : Tree) (n : nat), eq (tsize (tinsert t n)) (plus 1 (tsize t)).", "list_append_ass_theorem0": "Theorem theorem0 : forall (x : Lst) (y : Lst) (z : Lst), eq (append x (append y z)) (append (append x y) z).", "tree_size_theorem0": "Theorem theorem0 : forall (x : Tree), ge (tsize x) 0.", "mult-int_theorem0": "Theorem theorem0 : forall (x : nat) (y : nat), eq (minus (mult x y) y) (mult (minus x 1) y).", "mult-int_theorem1": "Theorem theorem1 : forall (n : nat) (m : nat), eq (mult n m) (mult m n)."}